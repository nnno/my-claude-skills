---
name: inspector2-risk-assessor
description: >
  AWS Inspector2の脆弱性findingを分析し、ソースコードの実際の使用状況に基づいた実質的リスク評価レポートを生成する。
  CVE番号やInspector2のfinding情報（JSON/テキスト）が提示された時、「脆弱性を評価して」「CVEの影響を調べて」
  「Inspector2のfindingを分析して」「セキュリティリスクを評価して」「このCVEうちのコードに影響ある？」
  「パッケージの脆弱性を調査して」「セキュリティfindingのトリアージをして」と依頼された時に使用する。
  Also triggers for "assess this vulnerability", "check CVE impact", "analyze Inspector2 findings",
  "evaluate security risk". 一般的なセキュリティ相談、AWSインフラ構成のレビュー、Inspector2のセットアップには使用しない。
---

# Inspector2 Risk Assessor

AWS Inspector2のfindingからCVE詳細を調査し、プロジェクトのソースコードにおける実際の影響を評価してリスクレポートを出力する。

## ワークフロー

以下の4ステップで実行する。ソースコード分析を最重要フェーズとして重点的にリソースを割く。
並列実行可能な部分は積極的にTask toolで並列化し、全体の実行時間を短縮する。

### Step 1: Finding情報の解析 → 並列フェーズの起動

まずユーザーが提示した情報から以下を抽出する（メインエージェントで即座に実行）:

- CVE ID（例: CVE-2024-12345）
- 対象パッケージ名とバージョン
- Inspector2の重要度（CRITICAL/HIGH/MEDIUM/LOW）
- 影響を受けるリソース（ECRイメージ、Lambda関数等）

入力形式は以下のいずれか:
- Inspector2のfinding JSON
- テキスト形式のfinding概要
- CVE番号のみ（パッケージ名をユーザーに確認する）

情報が不足する場合はユーザーに確認を求める。

**パッケージ名が確定した時点で、以下の2つのサブエージェントを並列起動する:**

#### 並列タスクA: CVE簡易確認（Task tool, model: haiku）

Finding情報に含まれるCVSSスコアや重要度をそのまま利用し、WebSearchは最小限にとどめる:
- `CVE-XXXX-XXXXX` で1クエリのみ実行し、脆弱性の種類と影響を受ける機能名を把握する
- Finding JSONにCVSS情報がある場合、NVDへの追加検索は不要
- PoCや詳細な攻撃条件の調査は行わない

返却する情報:
- 脆弱性の種類（RCE/DoS/情報漏洩等）
- 影響を受ける機能・コンポーネント名（ソースコード検索のキーワード）
- 修正バージョン（判明していれば）

#### 並列タスクB: ソースコード存在箇所の網羅的探索（Task tool, model: sonnet）

パッケージ名をキーにプロジェクト全体を走査し、すべての存在箇所を特定する。
以下のすべてのレイヤーを**並列にGrep/Glob**で走査する:

**依存定義ファイル:**
```
Glob: "**/package.json", "**/package-lock.json", "**/yarn.lock", "**/pnpm-lock.yaml"
Glob: "**/requirements*.txt", "**/Pipfile*", "**/poetry.lock"
Glob: "**/go.mod", "**/go.sum"
Glob: "**/pom.xml", "**/build.gradle*", "**/Gemfile*", "**/Cargo.toml"
```

**コンテナ・ビルド構成（バイナリ含有の検出に重要）:**
```
Glob: "**/Dockerfile*", "**/docker-compose*.yml", "**/.dockerignore"
Grep: "{パッケージ名}" in Dockerfile* — COPY, ADD, RUN命令での取り込み
Grep: "{パッケージ名}" in docker-compose*.yml — ボリュームマウント、イメージ参照
```

**ビルドスクリプト・CI/CD:**
```
Glob: "**/Makefile", "**/Taskfile*", "**/*.sh"
Glob: "**/.github/workflows/*.yml", "**/buildspec.yml", "**/cloudbuild.yaml"
Grep: "{パッケージ名}" in above files
```

**バイナリ・実行ファイルの直接検索:**
```
Grep: "{パッケージ名}" — プロジェクト全体でパッケージ名の出現を網羅検索
Glob: "**/{パッケージ名}", "**/{パッケージ名}.*" — バイナリファイルとして配置されている場合
```

**推移的依存の確認:**
- `npm ls {pkg}` / `yarn why {pkg}` / `pnpm why {pkg}`
- `pip show {pkg}` / `pip freeze | grep {pkg}`
- `go mod graph | grep {pkg}`
- lock ファイル内の直接検索（Grep）

返却する情報: 検出された全存在箇所のリスト（ファイルパス、検出レイヤー、使用コンテキストの概要）

### Step 2: 存在箇所ごとの影響分析

並列タスクA・Bの結果を統合した後、検出された**各存在箇所について並列にサブエージェントを起動**して影響分析を行う。

#### 各存在箇所の分析サブエージェント（Task tool, model: sonnet）

CVE簡易確認で得た脆弱な機能名を検索キーワードとして使い、以下を分析する:

1. **使用コンテキストの特定**: その箇所でパッケージ/バイナリがどう使われているか
   - ライブラリとしてimport/requireされている場合 → 脆弱な関数の呼び出し箇所をGrep
   - バイナリとして実行される場合 → 実行コマンド、引数、入力ソースを確認
   - ビルド時のみ使用される場合 → ランタイムへの影響有無を確認
   - 別パッケージの内部依存として含まれる場合 → 親パッケージ経由での脆弱機能の呼び出し有無を確認

2. **外部入力の到達可能性**: 攻撃に必要な入力がその箇所に到達するか
   - HTTPリクエスト、ファイルアップロード、環境変数、CLI引数等の経路を追跡
   - ネットワーク公開状況（Dockerfile/docker-compose/ECS定義等から判断）

3. **実行環境の特定**: その箇所がどの環境で動作するか
   - 本番コンテナ内 / ビルド環境のみ / ローカル開発のみ / テスト環境のみ

存在箇所が1つだけの場合はサブエージェントを使わずメインエージェントで直接分析する。

### Step 3: 実質的リスク評価

Step 2の各サブエージェントの分析結果を統合し、**存在箇所ごとに**リスクを評価する。

**攻撃成立性の判定（各存在箇所ごと）:**
- 脆弱な機能が実際に使用されているか
- 攻撃に必要な入力が外部から到達可能か
- ネットワーク経由のアクセスが必要な場合、対象サービスは外部公開されているか
- 攻撃に必要な前提条件（認証、特定設定等）がこの環境で満たされるか

**実質リスクレベルの判定基準:**

| レベル | 条件 |
|---|---|
| **Critical** | 脆弱な機能を使用 + 外部入力が到達可能 + 攻撃複雑性が低い |
| **High** | 脆弱な機能を使用 + 外部入力が到達可能だが攻撃に条件がある |
| **Medium** | 脆弱な機能を使用しているが外部入力の到達が限定的 |
| **Low** | パッケージは使用しているが脆弱な機能は未使用 |
| **Informational** | パッケージのバージョンは該当するが実質的影響なし（ビルド時のみ等） |

**総合リスクレベル**: 全存在箇所の中で最も高いリスクレベルを採用する。

### Step 4: レポート出力

`references/report-template.md` のテンプレートに従い、レポートを出力する。
存在箇所が複数ある場合は「ソースコード分析」セクションで**すべての存在箇所を列挙**し、それぞれのリスク評価を明記する。

## 並列実行の全体像

```
Step 1: Finding解析（メイン）
  │
  ├─ 並列タスクA: CVE簡易確認（haiku）
  │
  └─ 並列タスクB: 存在箇所の網羅的探索（sonnet）
       │  ※ B内部でも複数Grep/Globを並列実行
       ▼
Step 2: A・Bの結果を統合 → 各存在箇所の影響分析を並列起動（sonnet × N箇所）
       │
       ▼
Step 3: 全結果を統合 → リスク評価（メイン）
       │
       ▼
Step 4: レポート出力（メイン）
```

## モデル選択ガイドライン

各タスクで使用するモデルを最適化してコストを抑える:

| タスク | 推奨モデル | 理由 |
|---|---|---|
| 並列タスクA: CVE簡易確認 | **haiku** | WebSearch 1クエリ＋情報抽出のみ |
| 並列タスクB: 存在箇所探索 | **sonnet** | 多数のGrep/Globの結果を構造化して返す |
| Step 2: 各存在箇所の影響分析 | **sonnet** | コード理解の精度が必要 |
| Step 3-4: 評価・レポート | メインエージェント | 全結果の総合判断 |

Task toolでサブエージェントを起動する際は上記のモデルを `model` パラメータで指定する。

## 重要な注意事項

- **ソースコード分析を最優先**: CVE詳細調査に時間をかけず、ソースコード内の実際の影響分析に集中する
- Inspector2の重要度と実質リスクレベルが異なる場合、その差分の理由を必ず明記する
- 「影響なし」と判断する場合でも、判断根拠を具体的に示す
- **すべての存在箇所を報告**: パッケージやバイナリが複数箇所に存在する場合、漏れなく全箇所を報告する
- 修正方法は具体的なバージョン番号やコード変更案を含める
- 不確実な点がある場合は「要確認」として明示し、確認方法を提案する
- **バイナリ含有に注意**: npmパッケージ内のネイティブバイナリ（esbuildのGoバイナリ等）や、コンテナ内に直接配置されたバイナリも検出対象とする
